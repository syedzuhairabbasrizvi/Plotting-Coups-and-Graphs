W = {
    'Albania': ['Greece', 'Montenegro', 'Kosovo', 'North Macedonia'],
    'Andorra': ['France', 'Spain'],
    'Austria': ['Germany', 'Czech Republic', 'Slovakia', 'Hungary', 'Slovenia', 'Italy', 'Switzerland', 'Liechtenstein'],
    'Belarus': ['Russia', 'Latvia', 'Lithuania', 'Poland', 'Ukraine'],
    'Belgium': ['Netherlands', 'Germany', 'Luxembourg', 'France'],
    'Bosnia and Herzegovina': ['Croatia', 'Serbia', 'Montenegro'],
    'Bulgaria': ['Romania', 'Serbia', 'North Macedonia', 'Greece', 'Turkey'],
    'Croatia': ['Slovenia', 'Hungary', 'Serbia', 'Bosnia and Herzegovina', 'Montenegro'],
    'Czech Republic': ['Germany', 'Poland', 'Slovakia', 'Austria'],
    'Denmark': ['Germany'],
    'Estonia': ['Russia', 'Latvia'],
    'Finland': ['Sweden', 'Norway', 'Russia'],
    'France': ['Belgium', 'Luxembourg', 'Germany', 'Switzerland', 'Italy', 'Spain', 'Andorra', 'Monaco', 'United Kingdom'],
    'Germany': ['Denmark', 'Poland', 'Czech Republic', 'Austria', 'Switzerland', 'France', 'Netherlands', 'Belgium', 'Luxembourg'],
    'Greece': ['Albania', 'North Macedonia', 'Bulgaria', 'Turkey'],
    'Hungary': ['Austria', 'Slovakia', 'Ukraine', 'Romania', 'Serbia', 'Croatia', 'Slovenia'],
    'Iceland': ['Ireland', 'United Kingdom', 'Norway'],
    'Ireland': ['United Kingdom', 'Iceland'],
    'Italy': ['Malta', 'France', 'Switzerland', 'Austria', 'Slovenia', 'Vatican City', 'San Marino'],
    'Kosovo': ['Serbia', 'Montenegro', 'Albania', 'North Macedonia'],
    'Latvia': ['Estonia', 'Russia', 'Belarus', 'Lithuania'],
    'Liechtenstein': ['Switzerland', 'Austria'],
    'Lithuania': ['Latvia', 'Belarus', 'Poland'],
    'Luxembourg': ['Belgium', 'Germany', 'France'],
    'Malta': ['Italy'],
    'Moldova': ['Romania', 'Ukraine'],
    'Monaco': ['France'],
    'Montenegro': ['Bosnia and Herzegovina', 'Serbia', 'Kosovo', 'Albania', 'Croatia'],
    'Netherlands': ['Germany', 'Belgium'],
    'North Macedonia': ['Serbia', 'Kosovo', 'Albania', 'Greece', 'Bulgaria'],
    'Norway': ['Sweden', 'Finland', 'Russia', 'Iceland'],
    'Poland': ['Germany', 'Czech Republic', 'Slovakia', 'Ukraine', 'Belarus', 'Lithuania'],
    'Portugal': ['Spain'],
    'Romania': ['Hungary', 'Ukraine', 'Moldova', 'Bulgaria', 'Serbia'],
    'Russia': ['Norway', 'Finland', 'Estonia', 'Latvia', 'Belarus', 'Ukraine', 'Georgia', 'Azerbaijan', 'Kazakhstan', 'Mongolia', 'China', 'North Korea', 'Japan'],
    'San Marino': ['Italy'],
    'Serbia': ['Hungary', 'Romania', 'Bulgaria', 'North Macedonia', 'Kosovo', 'Montenegro', 'Bosnia and Herzegovina', 'Croatia'],
    'Slovakia': ['Poland', 'Czech Republic', 'Austria', 'Hungary', 'Ukraine'],
    'Slovenia': ['Austria', 'Hungary', 'Croatia', 'Italy'],
    'Spain': ['France', 'Portugal', 'Andorra'],
    'Sweden': ['Norway', 'Finland'],
    'Switzerland': ['Germany', 'Austria', 'Liechtenstein', 'Italy', 'France'],
    'Ukraine': ['Russia', 'Belarus', 'Poland', 'Slovakia', 'Hungary', 'Romania', 'Moldova'],
    'United Kingdom': ['Ireland', 'France', 'Iceland'],
    'Vatican City': ['Italy'],
    'Afghanistan': ['Iran', 'Pakistan', 'Turkmenistan', 'Uzbekistan', 'Tajikistan', 'China'],
    'Armenia': ['Georgia', 'Azerbaijan', 'Iran', 'Turkey'],
    'Azerbaijan': ['Russia', 'Georgia', 'Armenia', 'Iran'],
    'Bahrain': ['Saudi Arabia'],
    'Bangladesh': ['India', 'Myanmar'],
    'Bhutan': ['China', 'India'],
    'Brunei': ['Malaysia', 'Philippines'],
    'Cambodia': ['Thailand', 'Laos', 'Vietnam'],
    'China': ['Russia', 'Mongolia', 'North Korea', 'South Korea', 'Vietnam', 'Laos', 'Myanmar', 'Bhutan', 'Nepal', 'India', 'Pakistan', 'Afghanistan', 'Kazakhstan', 'Kyrgyzstan', 'Taiwan', 'Tajikistan'],
    'Cyprus': ['Turkey'],
    'Egypt': ['Israel', 'Palestine'],
    'Georgia': ['Russia', 'Armenia', 'Azerbaijan', 'Turkey'],
    'India': ['Pakistan', 'China', 'Nepal', 'Bhutan', 'Bangladesh', 'Myanmar', 'Sri Lanka'],
    'Indonesia': ['Malaysia', 'Papua New Guinea', 'Philippines', 'Timor-Leste', 'Australia'],
    'Iran': ['Iraq', 'Turkey', 'Armenia', 'Azerbaijan', 'Turkmenistan', 'Afghanistan', 'Pakistan'],
    'Iraq': ['Turkey', 'Syria', 'Jordan', 'Saudi Arabia', 'Kuwait', 'Iran'],
    'Israel': ['Lebanon', 'Syria', 'Jordan', 'Egypt', 'Palestine'],
    'Japan': ['South Korea', 'Russia'],
    'Jordan': ['Syria', 'Iraq', 'Saudi Arabia', 'Israel', 'Palestine'],
    'Kazakhstan': ['Russia', 'Uzbekistan', 'Kyrgyzstan', 'China', 'Turkmenistan'],
    'Kuwait': ['Iraq', 'Saudi Arabia'],
    'Kyrgyzstan': ['Kazakhstan', 'Uzbekistan', 'Tajikistan', 'China'],
    'Laos': ['China', 'Vietnam', 'Cambodia', 'Thailand', 'Myanmar'],
    'Lebanon': ['Syria', 'Israel'],
    'Malaysia': ['Thailand', 'Singapore', 'Indonesia', 'Brunei'],
    'Maldives': ['Sri Lanka'],
    'Mongolia': ['Russia', 'China'],
    'Myanmar': ['China', 'India', 'Bangladesh', 'Laos', 'Thailand'],
    'Nepal': ['China', 'India'],
    'North Korea': ['China', 'Russia', 'South Korea'],
    'Oman': ['Saudi Arabia', 'United Arab Emirates', 'Yemen'],
    'Pakistan': ['India', 'Afghanistan', 'Iran', 'China'],
    'Palestine': ['Egypt', 'Jordan', 'Israel'],
    'Papua New Guinea': ['Indonesia', 'Solomon Islands', 'Australia'],
    'Philippines': ['Brunei', 'Indonesia'],
    'Qatar': ['Saudi Arabia'],
    'Saudi Arabia': ['Iraq', 'Kuwait', 'Oman', 'Qatar', 'United Arab Emirates', 'Yemen', 'Jordan', 'Bahrain'],
    'Singapore': ['Malaysia'],
    'South Korea': ['North Korea', 'China', 'Japan'],
    'Sri Lanka': ['India', 'Maldives'],
    'Syria': ['Turkey', 'Iraq', 'Jordan', 'Israel', 'Lebanon'],
    'Taiwan': ['China'],
    'Tajikistan': ['Uzbekistan', 'Kyrgyzstan', 'China', 'Afghanistan'],
    'Thailand': ['Myanmar', 'Laos', 'Cambodia', 'Malaysia'],
    'Timor-Leste': ['Indonesia'],
    'Turkey': ['Greece', 'Bulgaria', 'Georgia', 'Armenia', 'Iran', 'Iraq', 'Syria', 'Cyprus'],
    'Turkmenistan': ['Kazakhstan', 'Uzbekistan', 'Iran', 'Afghanistan'],
    'United Arab Emirates': ['Oman', 'Saudi Arabia'],
    'Uzbekistan': ['Kazakhstan', 'Tajikistan', 'Kyrgyzstan', 'Turkmenistan', 'Afghanistan'],
    'Vietnam': ['China', 'Laos', 'Cambodia'],
    'Yemen': ['Saudi Arabia', 'Oman'],
    'Australia': ['Indonesia', 'Papua New Guinea', 'New Zealand'],
    'New Zealand': ['Australia'],
    'Solomon Islands': ['New Caledonia', 'Papua New Guinea'],
    'Fiji': ['New Caledonia'],
    'New Caledonia': ['Fiji', 'Solomon Islands']
}

#this is a world graph up there

mykeys = list(W.keys())
mykeys.sort()
new_W = {i : W[i] for i in mykeys}
W = new_W       #sorting for index table purposes later


def addNodes(G, nodes):     #adding nodes
    for x in nodes:
        G[x]=[]
    return G
    
def addEdges(G,edges, directed=False):      #adding edges
    if directed:
        for x in edges:
            G[x[0]].append((x[1]))
            G[x[1]].append((x[0]))
    else:
        for x in edges:
            G[x[0]].append((x[1]))
    return G

def getNeighbors(G, node):              #obtain neighbours of a node
    lst=[]
    for x in G[node]:
        lst.append(x)
    return lst

def removeNode(G, node):                #get rid of node and all its edges
    G.pop(node)
    for x,y in G.items():
        for z in y:
            if z==node:
                G[x].remove(z)
    return G

from pyvis.network import Network
import networkx as nx                   #for visualization purposes
from random import randint

def visualize_graph(W, name):               #this converts a graph data structure to a Networkx network and visualizes that using pyvis
    G = nx.Graph()

    # add nodes
    for country, neighbors in W.items():
        friends = len(neighbors) * 2
        G.add_node(country, size = friends,color='black')

    # add edges
    for country, neighbors in W.items():
        for neighbor in neighbors:
            G.add_edge(country, neighbor)

    # create the visualization
    nt = Network("1000px", "1000px", notebook=True,cdn_resources="remote")
    nt.from_nx(G)
    name += ".html"
    nt.show(name)

visualize_graph(W, "full")

def make_index_table():         #stores countries along with who owns them
    index_table = {}
    count=0
    for x in W:
        index_table[count]=[x,"O"]
        count+=1
    return index_table

index_table = make_index_table()

def index_table_checker(index_table):               #gives random country and occupation state
    key = randint(0, len(index_table)-1)
    country = index_table[key][0]
    country_check= index_table[key][1]
    return (country,country_check,key)


def make_player_graph(playerno):            #constructs a random graph of 10 countries
    global W
    global index_table
    g_p1 = {}
    countries = []
    key = None
    for x in range(10):   
        country_check=""
        while country_check!="O":
            country_stats=index_table_checker(index_table)
            country=country_stats[0]
            country_check=country_stats[1]
            key=country_stats[2]
        countries.append(country)
        index_table[key][1]="X"+str(playerno)
    addNodes(g_p1, countries)
    firmbors=[]
    for country in g_p1:   
        maybors = getNeighbors(W, country)
        for maybor in maybors:
            if maybor in g_p1:
                firmbors.append([country, maybor])
    addEdges(g_p1, firmbors, False)
    return g_p1

def addCountry(g_p1, country):              #add country along with its possible edges in the player graph depending on whether neighbors are present
    addNodes(g_p1, [country])
    maybors = getNeighbors(W, country)
    firmbors=[]
    for maybor in maybors:
        if maybor in g_p1:
            firmbors.append([country, maybor])
            firmbors.append([maybor, country])
    addEdges(g_p1, firmbors, False)

def check_win(G):                       #checks if five neighbor countries are present; if so, returns these countries
    for country in G:
        emp_no=empire_num_check(G,[],0,country)
        if emp_no>=5:
            return empire(G,[],country)


def empire_num_check(g_p1,visited, emp_no, source):                 #recursive DFS algorithm to traverse possible winning empire
    emp_no+=1
    visited.append(source)
    for neighbor in g_p1[source]:
        if neighbor not in visited:
            emp_no+=empire_num_check(g_p1,visited, 0, neighbor)
    return emp_no

def empire(g_p1,visited, source):                       #recursive call for DFS algorithm
    visited.append(source)
    for neighbor in g_p1[source]:
        if neighbor not in visited:
            empire(g_p1,visited, neighbor)
    return visited

g_p1 = make_player_graph(1)
    
g_p2 = make_player_graph(2)

import pygame                   #because how else can you make a game in python?
import webbrowser               #to access visualization

pygame.init()

pygame.display.set_caption("Plotting Coups and Graphs")

chal_count_1=3
chal_count_2=3
# Set up the screen
screen_width = 800
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))

WHITE = (255,255,255)
BLACK = (0,0,0)

BUTTON_WIDTH = 200
BUTTON_HEIGHT = 50
BUTTON_COLOR = WHITE
BUTTON_HOVER_COLOR = (200, 200, 200)

box_x = 600
box_y = 50
box_width = 30
box_height = 50

# Load the first image
title_screen = pygame.image.load("title screen.png")
ins_screen = pygame.image.load("ins screen.png")
game_screen = pygame.image.load("game.png")

# Set the color of the box and the width of the border
box_color = WHITE
border_width = 3

# Set up the fonts
font = pygame.font.SysFont('Rubik Regular', 25)
thinfont = pygame.font.SysFont('Rubik', 25)
chalfont = pygame.font.SysFont('ScriptC', 25)
bigfont = pygame.font.SysFont('Rubik Semibold', 25)

# Set up the main button
button_rect = pygame.Rect((screen_width-BUTTON_WIDTH)//2, (screen_height-BUTTON_HEIGHT)//2, BUTTON_WIDTH, BUTTON_HEIGHT)
button_text = bigfont.render("Roll Die", True, BLACK)
button_text_rect = button_text.get_rect(center=button_rect.center)

# Create the text surface
text = font.render("Player 1", True, WHITE)
text_2 = font.render("Player 2", True, WHITE)
text_width, text_height = text.get_size()
text_2_width, text_2_height = text_2.get_size()

text_c = chalfont.render("C", True, WHITE)
text_time = font.render("x", True, WHITE)

# Calculate the position of the text for the player names
text_x = 48
text_y = 30
text2_x = screen_width-text_2_width-48
text2_y = screen_height-text_2_height-30

# This is for the graph buttons

box_graph_1 = pygame.Rect(50, 100, BUTTON_WIDTH, BUTTON_HEIGHT)
box_graph_2 = pygame.Rect(550, 450, BUTTON_WIDTH, BUTTON_HEIGHT)
chal_graph_1 = pygame.Rect(300, 500, BUTTON_WIDTH, BUTTON_HEIGHT)
chal_graph_2 = pygame.Rect(550, 500, BUTTON_WIDTH, BUTTON_HEIGHT)

# And this is for the accompanying texts

bg1_text = font.render("P1 Network", True, BLACK)
bg2_text = font.render("P2 Network", True, BLACK)
bg1_axis = bg1_text.get_rect(center=box_graph_1.center)
bg2_axis = bg2_text.get_rect(center=box_graph_2.center)
chal_bg1_axis = bg1_text.get_rect(center=chal_graph_1.center)
chal_bg2_axis = bg2_text.get_rect(center=chal_graph_2.center)
chal_prompt = thinfont.render("Challenge?", True, WHITE)

# Visualization of both graphs

visualize_graph(g_p1, "Player_1")
visualize_graph(g_p2, "Player_2")

#Note: for this part, please update the links according to your download path. Otherwise, the code will not run as expected.

link_p1 = "file:///E:/HUNotes/Freshman%20Spring/DSA/Project/Player_1.html"                     #UPDATE PATH ACCORDING TO YOUR DOWNLOAD LOCATION
link_p2 = "file:///E:/HUNotes/Freshman%20Spring/DSA/Project/Player_2.html"                      #UPDATE PATH ACCORDING TO YOUR DOWNLOAD LOCATION

# More buttons and texts

world_button = pygame.Rect((screen_width-BUTTON_WIDTH)//2, 450, BUTTON_WIDTH, BUTTON_HEIGHT)
world_text = bigfont.render("World Network", True, BLACK)
world_text_rect = world_text.get_rect(center=world_button.center)
win_button = pygame.Rect(300, 400, BUTTON_WIDTH, BUTTON_HEIGHT)
again_button = pygame.Rect(550, 400, BUTTON_WIDTH, BUTTON_HEIGHT)
see_text = font.render("See Empire", True, BLACK)
again_text = font.render("Play Again", True, BLACK)
see_axis = see_text.get_rect(center=win_button.center)
again_axis = again_text.get_rect(center=again_button.center)
yes_text = font.render("Yes", True, BLACK)
yes_axis = see_text.get_rect(center=win_button.center)
no_text = font.render("No", True, BLACK)
no_axis = see_text.get_rect(center=again_button.center)

# Flags, flags everywhere

button_clicked=False
miniwin_1=False
miniwin_2=False
playflag="1"
result_1 = None
result_2 = None
restart = False
prompt_1 = False
prompt_2 = False
win_chal = False
stopnow = False
title = True
instructions = False
running = True

def winning_function(win_num, result):                          # Procedure for when a player wins the game
    global running
    while True:
        for event in pygame.event.get():
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or event.type == pygame.QUIT:
                return
            screen.fill((0, 0, 0))
            win_text = font.render("Player "+str(win_num)+" won with an empire of:", True, WHITE)
            empire = ", ".join(result)
            empire_text = font.render(empire, True, WHITE)
            count=0
            for x in result:
                count+=1
                empire_text = thinfont.render(x, True, WHITE)
                screen.blit(empire_text, (50, 50+50*count))
            screen.blit(win_text, (50,50))
            pygame.draw.rect(screen, WHITE, win_button)
            screen.blit(see_text, see_axis)
            pygame.draw.rect(screen, WHITE, again_button)
            screen.blit(again_text, again_axis)
            if win_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, win_button)
            if again_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, again_button)
            if event.type == pygame.MOUSEBUTTONDOWN and not button_clicked:
                if again_button.collidepoint(pygame.mouse.get_pos()):
                    running=True
                    return
                elif win_button.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open("file:///E:/HUNotes/Freshman%20Spring/DSA/Project/wii.html")                #UPDATE PATH ACCORDING TO YOUR DOWNLOAD LOCATION
                button_clicked=True
            if event.type == pygame.MOUSEBUTTONUP:
                button_clicked = False
            pygame.display.flip()

def win_chal_fun(C, win_chal):                      # Procedure for winning or losing the challenge
    global stopnow
    while True:
        for event in pygame.event.get():
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or event.type == pygame.QUIT:
                stopnow = True
                return
            screen.fill(BLACK)
            if win_chal:
                string = "Player "+str(C)+" wins "
            else:
                string = "Player "+str(C%2+1)+" keeps "
            if C==1:
                string+=country
            elif C==2:
                string+=country2
            text = thinfont.render(string, True, WHITE)
            screen.blit(text, (100, 200))
            pygame.draw.rect(screen, WHITE, again_button)
            if again_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, again_button)
            button_text = font.render("Continue", True, BLACK)
            screen.blit(button_text, again_axis)
            if event.type == pygame.MOUSEBUTTONDOWN:
                if again_button.collidepoint(pygame.mouse.get_pos()):
                    return
            pygame.display.flip()

def challenge(C):                           # Procedure for the challenge prompt
    global prompt_1
    global prompt_2
    global miniwin_1
    global miniwin_2
    global chal_count_1
    global chal_count_2
    global win_chal
    global stopnow
    global link_p1
    global link_p2
    if C==1:
        count=chal_count_1
    elif C==2:
        count=chal_count_2
    miniwin_1=False
    miniwin_2=False
    prompt_1=False
    prompt_2=False
    button_clicked=False
    while True:
        for event in pygame.event.get():
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or event.type == pygame.QUIT:
                stopnow=True
                return
            screen.fill(BLACK)
            if C==1:
                prompt_string = "Player 2 owns "+country
            elif C==2:
                prompt_string = "Player 1 owns "+country2
            prompt_text_1 = thinfont.render(prompt_string, True, WHITE)
            screen.blit(prompt_text_1, (100, 200))
            screen.blit(chal_prompt, (100,250))
            pygame.draw.rect(screen, WHITE, win_button)
            pygame.draw.rect(screen, WHITE, again_button)
            cards_text = font.render("Cards: "+str(count), True, WHITE)
            screen.blit(cards_text, (100, 300))

            pygame.draw.rect(screen, WHITE, chal_graph_1)
            pygame.draw.rect(screen, WHITE, chal_graph_2)
            if chal_graph_1.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, chal_graph_1)
            if chal_graph_2.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, chal_graph_2)
            if event.type == pygame.MOUSEBUTTONDOWN and not button_clicked:
                if chal_graph_1.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open(link_p1)
                if chal_graph_2.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open(link_p2)
                button_clicked=True
            if event.type == pygame.MOUSEBUTTONUP:
                        button_clicked = False

            screen.blit(bg1_text, chal_bg1_axis)
            screen.blit(bg2_text, chal_bg2_axis)
            if win_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, win_button)
            if again_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, again_button)
            screen.blit(yes_text, yes_axis)
            screen.blit(no_text, no_axis)
            if event.type == pygame.MOUSEBUTTONDOWN:
                if win_button.collidepoint(pygame.mouse.get_pos()):
                    if C==1 and count>0:
                        count-=1
                        winner=randint(1,2)
                        if winner==1:
                            win_chal=True
                        elif winner==2:
                            win_chal=False
                        chal_count_1=count
                        return
                    elif C==2 and count>0:
                        count-=1
                        winner=randint(1,2)
                        if winner==2:
                            win_chal=True
                        elif winner==1:
                            win_chal=False
                        chal_count_2=count
                        return
                elif again_button.collidepoint(pygame.mouse.get_pos()):
                    return
            pygame.display.flip()

# The main code starts here

while running:
    while title:
        if instructions:
            screen.blit(ins_screen, (0,0))          #show instructions
        else:
            screen.blit(title_screen, (0,0))        #show title
        pygame.display.update()         #update screen
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:       #press enter to start
                title=False                         
                instructions=False                                  
            elif (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or event.type == pygame.QUIT:          #press esc to quit
                title=False
                running = False
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_BACKSPACE:              #press backspace for instructions
                instructions=True
    for event in pygame.event.get():
        if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or event.type == pygame.QUIT:
            running = False                         #escape during game
        else:
            chal_text = font.render(str(chal_count_1), True, WHITE)
            chal_text_2 = font.render(str(chal_count_2), True, WHITE)                       #number of cards per player
            screen.fill(BLACK)
            screen.blit(game_screen,(0,0))
            screen.blit(text, (text_x, text_y))
            screen.blit(text_2, (text2_x, text2_y))                                 #initialize basic screen

            pygame.draw.rect(screen, WHITE, button_rect)
            pygame.draw.rect(screen, WHITE, world_button)                               #make button to show world network
            if button_rect.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, button_rect)                       #hover over button to change color
                if event.type == pygame.MOUSEBUTTONDOWN and not button_clicked:
                    if playflag=="1":
                        country_stats=index_table_checker(index_table)
                        country=country_stats[0]
                        country_check=country_stats[1]
                        key=country_stats[2]                            #obtain random country for player 1
                        playflag="2"
                        while country_check=="X1":
                            country_stats=index_table_checker(index_table)
                            country=country_stats[0]
                            country_check=country_stats[1]
                            key=country_stats[2]                                        #make sure it isn't already in player 1
                        print(country, country_check, "1")  
                        if country_check=="O":
                            miniwin_1=True
                            change_g1_now=True
                            addCountry(g_p1, country)
                            index_table[key][1]="X1"
                            button_clicked=True
                            result_1 = check_win(g_p1)                      #add to player 1, check if player 1 has won
                        else:
                            prompt_1 = True                     #challenge situation
                            
                    elif playflag=="2":
                        country_stats2=index_table_checker(index_table)         #above, but for player 2
                        country2=country_stats2[0]
                        country_check2=country_stats2[1]
                        key2=country_stats2[2]
                        playflag="1"
                        while country_check2=="X2":
                            country_stats2=index_table_checker(index_table)
                            country2=country_stats2[0]
                            country_check2=country_stats2[1]
                            key2=country_stats2[2]
                        print(country2, country_check2, "2")
                        if country_check2=="O":
                            miniwin_2=True
                            change_g2_now=True
                            addCountry(g_p2, country2)
                            index_table[key2][1]="X2"
                            button_clicked=True
                            result_2 = check_win(g_p2)
                        else:
                            prompt_2 = True
            if prompt_1==True:                              #challenge sequence
                challenge(1)
                if stopnow:
                    pygame.quit()
                    quit()                              #quit during challenge
                else:
                    win_chal_fun(1, win_chal)                           #graphic sequence for winning or losing challenge
                    if stopnow:
                        pygame.quit()
                        quit()
                    elif win_chal==True:
                        removeNode(g_p2,country)                            #player 1 steals country from player 2
                        addCountry(g_p1,country)
                        index_table[key][1]="X1"
                        visualize_graph(g_p1, "Player_1")
                        visualize_graph(g_p2, "Player_2")
                        win_chal=False
            elif prompt_2==True:
                challenge(2)   
                if stopnow:                         #ditto, but for player 2 this time
                    pygame.quit()
                    quit()
                else:
                    win_chal_fun(2, win_chal)
                    if stopnow:
                        pygame.quit()
                        quit()
                    elif win_chal==True:
                        removeNode(g_p1,country2)
                        addCountry(g_p2,country2)
                        index_table[key][1]="X2"
                        visualize_graph(g_p1, "Player_1")
                        visualize_graph(g_p2, "Player_2")
                        win_chal=False 
            if miniwin_1:                                       #visual update for player 1 winning a country
                string = "P1 wins: "+ str(country)
                miniwin_text = thinfont.render(string, True, WHITE)
                screen.blit(miniwin_text, (50, 175))
                index_table[key][1]="X1"                            #it's now player 1's country, so change state
                if change_g1_now:
                    visualize_graph(g_p1, "Player_1")                               #update html file                  
                    change_g1_now=False
                
            
            if miniwin_2:
                string_2 = "P2 wins: "+ str(country2)                   #same, but player 2 now
                miniwin_text_2 = thinfont.render(string_2, True, WHITE)
                screen.blit(miniwin_text_2, (400, 400))
                index_table[key][1]="X2"
                if change_g2_now:
                    visualize_graph(g_p2, "Player_2")
                    change_g2_now=False
                
            if world_button.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, world_button)                      #hover button color

            if event.type == pygame.MOUSEBUTTONDOWN and not button_clicked:
                if world_button.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open("file:///E:/HUNotes/Freshman%20Spring/DSA/Project/full.html")           #UPDATE PATH ACCORDING TO YOUR DOWNLOAD LOCATION

            screen.blit(button_text, button_text_rect)
            screen.blit(world_text, world_text_rect)                                #draw button texts

            screen.blit(text_c, (box_x+26, box_y+17))
            screen.blit(text_c, (106, 517))
            screen.blit(text_time, (box_x+63, box_y+20))
            screen.blit(text_time, (143, 520))
            screen.blit(chal_text, (box_x+85, box_y+20))
            screen.blit(chal_text_2, (165, 520))                    #draw cards texts. chal text gets updated if challenge happens
            # Draw the box with a border
            pygame.draw.rect(screen, box_color, (box_x+20, box_y, box_width, box_height), border_width)         #the box for cards is drawn
            pygame.draw.rect(screen, box_color, (100, 500, box_width, box_height), border_width)
            pygame.draw.rect(screen, WHITE, box_graph_1)                        #button for player 1 network
            pygame.draw.rect(screen, WHITE, box_graph_2)                        #button for player 2 network

            if box_graph_1.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, box_graph_1)
            if box_graph_2.collidepoint(pygame.mouse.get_pos()):
                pygame.draw.rect(screen, BUTTON_HOVER_COLOR, box_graph_2)

            if event.type == pygame.MOUSEBUTTONDOWN and not button_clicked:
                if box_graph_1.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open(link_p1)                    #open player 1 network
                elif box_graph_2.collidepoint(pygame.mouse.get_pos()):
                    webbrowser.open(link_p2)                       #open player 2 network
                button_clicked=True

            if event.type == pygame.MOUSEBUTTONUP:
                    button_clicked = False                  #mechanism to ensure holding button does not make many tabs open
            
            screen.blit(bg1_text, bg1_axis)
            screen.blit(bg2_text, bg2_axis)
            screen.blit(text, (text_x, text_y))                         #more texts

        
        if result_1!=None or result_2!=None:
            running=False                               #if one of them wins, stop gaming sequence

        if running==False:
            if result_1!=None:                                  #this is the winning sequence for either player
                visualize_graph(g_p1, "wii")
                winning_function(1, result_1)
            elif result_2!=None:
                visualize_graph(g_p2, "wii")
                winning_function(2, result_2)
            if running==True:
                index_table=make_index_table()                      #the player has chosen to play again, so everything is re-initialized
                g_p1 = make_player_graph(1)
                g_p2 = make_player_graph(2)
                result_1=None
                result_2=None
                miniwin_1=False
                miniwin_2=False
                chal_count_1=3
                chal_count_2=3
                visualize_graph(g_p1, "Player_1")
                visualize_graph(g_p2, "Player_2")
                playflag="1"
                restart=True
        pygame.display.flip()                   #update display per frame
